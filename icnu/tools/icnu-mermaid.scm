(define-module (icnu tools icnu-mermaid)
  #:use-module (icnu icnu)
  #:use-module (icnu utils format)
  #:use-module (icnu utils strings)
  #:use-module (icnu utils log)
  #:export (net->mermaid-string write-mermaid-file sanitize-id-ml escape-ml-label))

(define (sanitize-id-ml s)
  (let ((sstr (if (symbol? s) (symbol->string s) (format-string #f "~a" s))))
    (let loop ((chars (string->list sstr)) (out "n"))
      (if (null? chars)
          out
          (let ((c (car chars)))
            (let ((ok (or (char-numeric? c) (char-alphabetic? c) (char=? c #\_))))
              (loop (cdr chars)
                    (string-append out
                                   (if ok
                                       (string c)
                                       "_")))))))))

(define (escape-ml-label s)
  (let* ((raw (if (symbol? s) (symbol->string s) (format-string #f "~a" s)))
         (escaped-backslash (string-replace-char raw "\\" "\\\\"))
         (escaped-quote (string-replace-char escaped-backslash "\"" "\\\""))
         (escaped-newline (string-replace-char escaped-quote "\n" "\\n"))
         (escaped-lb (string-replace-char escaped-newline "[" "_"))
         (escaped-rb (string-replace-char escaped-lb "]" "_"))
         (escaped-lp (string-replace-char escaped-rb "(" "_"))
         (escaped-rp (string-replace-char escaped-lp ")" "_"))
         (escaped-lc (string-replace-char escaped-rp "{" "_"))
         (escaped-rc (string-replace-char escaped-lc "}" "_")))
    escaped-rc))

(define (node-label-for-ml net name)
  (let* ((agent (node-agent net name))
         (tag   (node-tag net name))
         (meta  (node-meta net name))
         (meta-str (if meta (format-string #f "~a" meta) "")))
    (format-string #f "~a agent=~a tag=~a~a"
                   name
                   (if agent agent "")
                   (if tag tag "user/opaque")
                   (if (string=? meta-str "") "" (format-string #f " meta=~a" (escape-ml-label meta-str))))))

(define (net->mermaid-string net)
  (let ((lines '()))
    (define (emit fmt . args)
      (set! lines (cons (apply format-string #f fmt args) lines)))
    (emit "flowchart LR")
    
    (define (emit-node-definition name agent)
      (when (not (eq? agent 'V))
        (let* ((id (sanitize-id-ml name))
               (lbl (let ((raw (node-label-for-ml net name)))
                      (if (string? raw) raw (format-string #f "~a" raw))))
               (lbl-esc (escape-ml-label lbl))
               (color (cond ((eq? agent 'A) "#f9f")
                            ((eq? agent 'C) "#9ff")
                            ((eq? agent 'E) "#ff9")
                            (else "#fff")))
               (shape (cond ((eq? agent 'A) (format-string #f "~a[~a]" id lbl-esc))
                            ((eq? agent 'C) (format-string #f "~a(~a)" id lbl-esc))
                            ((eq? agent 'E) (format-string #f "~a{~a}" id lbl-esc))
                            (else (format-string #f "~a[~a]" id lbl-esc)))))
          (emit "  subgraph ~a_group" id)
          (emit "    ~a" shape)
          (emit "    style ~a fill:~a,stroke:#333,stroke-width:2px" id color)
          (let ((ports (get-ports agent)))
            (when ports
              (for-each (lambda (p)
                          (let ((pid (format-string #f "~a_~a" id (symbol->string p))))
                            (emit "      ~a((~a))" pid (symbol->string p))
                            (emit "      style ~a fill:none,stroke:none" pid)))
                        ports))
            (emit "  end")))))

    (let ((nu-nodes '())
          (other-nodes '()))
      (hash-for-each
       (lambda (name agent)
         (if (node-nu? net name)
             (set! nu-nodes (cons (cons name agent) nu-nodes))
             (set! other-nodes (cons (cons name agent) other-nodes))))
       (net-nodes net))
      (when (not (null? nu-nodes))
        (emit "  subgraph NU_SCOPE")
        (emit "    style NU_SCOPE fill:#eee,stroke:#999,stroke-dasharray: 5 5")
        (for-each (lambda (p) (emit-node-definition (car p) (cdr p))) (reverse nu-nodes))
        (emit "  end"))
      (for-each (lambda (p) (emit-node-definition (car p) (cdr p))) (reverse other-nodes)))
    (let ((seen (make-hash-table)))
	    (hash-for-each
	     (lambda (ep peer)
	       (when (and (pair? ep) (pair? peer))
		       (let* ((a (car ep)) (pa (cdr ep))
		              (b (car peer)) (pb (cdr peer))
		              (ka (format-string #f "~a|~a" a pa))
		              (kb (format-string #f "~a|~a" b pb))
		              (key (if (and (symbol? a) (symbol? b)
					                      (string<? (symbol->string a) (symbol->string b)))
	                         (string-append ka "##" kb)
	                         (string-append kb "##" ka))))
	           (unless (hash-ref seen key #f)
		           (hash-set! seen key #t)
		           (let* ((sorted? (and (symbol? a) (symbol? b) (string<? (symbol->string a) (symbol->string b))))
		                  (node1 (if sorted? a b))
		                  (port1 (if sorted? pa pb))
		                  (node2 (if sorted? b a))
		                  (port2 (if sorted? pb pa))
		                  (id1 (sanitize-id-ml node1))
		                  (id2 (sanitize-id-ml node2))
		                  (pid1 (format-string #f "~a_~a" id1 (symbol->string port1)))
		                  (pid2 (format-string #f "~a_~a" id2 (symbol->string port2))))
	               (emit "  ~a --> ~a" pid1 pid2))))))
	     (net-links net)))
    (string-append (string-join-list (reverse lines) "\n") "\n")))


(define (write-mermaid-file net path)
  (let ((s (net->mermaid-string net)))
    (call-with-output-file path
      (lambda (port)
	      (display s port)
	      (force-output port))))
  path)
